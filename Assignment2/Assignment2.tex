\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}

\begin{document}
\title{Functional Programming \\ Exercise set 2}
\date{\today}
\author{Tony Lopar s1013792 \\ Carlo Jessurun s1013793 \\ Marnix Dessing s1014097}
\maketitle

\section*{Exercise 1}
\begin{enumerate}
  \item There are four functions possible, since the a Bool has two possible values. For both possible inputs there is a function that gives a for both one value. The functions that may exist are a function that only gives true, a function that only gives true, the identity function and the inverse. The defined functions may be found in the attached file Exercise1.lhs.
  \item There are 8 functions possible. Since there are 4 possible combinations possible as input. These four combinations all have two possible outputs. The defined functions may be found in the attached file Exercise1.lhs.
  \item The type $Bool \rightarrow Bool \rightarrow Bool$ may be a function that takes two parameters as input and returns a boolean or it may be a function that takes one Bool as input and returns a function from Bool to Bool. In the case of two values as input we have eight options as seen in the previous question. In the case that we return a funciton from Bool to Bool we also have 8 possibilities since there are two possible inputs and four function possible from Bool to Bool.
\end{enumerate}

\section*{Exercise 2}

\newpage
\section*{Exercise 3}
Repeat the exercise using the type annotation ::Integer. What do you observe? Can you explain the differences?\\
\newline
The interesting output:
\begin{lstlisting}
Prelude: product [1..66] :: Int
0
Prelude: product [1..66] :: Integer
544344939077443064003729240247842752644293064388798874532860126869671081148416000000000000000
\end{lstlisting}
The Int type is defined as ``A fixed-precision integer type with at least the range $[-2^{29} \dots. 2^{29-1}]$.'' $[0]$ The range varies by machine but you can find it with minBound and maxBound
\newline
The reason it overflows is that it's got a fixed amount of memory allocated for it. Imagine a simpler example - a positive integer in memory whose maximum value was 7 (stored as 3 bits in memory)
\newline
\newline
0 is represented as 000, in binary\\
1 is represented as 001\\
2 is represented as 010, etc.\\
\newline
Note how the bit math works: when you add 1, you either turn the smallest digit from 0 to 1, or you turn it from 1 to 0 and do the same operation on the next-most-significant digit.
\newline
\newline
Now if you naievely (as Haskell does) perform this when there's no next-most-significant digit, then it just increments as usual, but ``gets its head cut off.'' E.g. 111 + 1 becomes 000 instead of 1000. This is what's happening with Haskell, except that its lowest value (represented as a series of 0s) is its lowest negative number. it uses its ``leftmost'' bit to represent +/-. You'll need to do (maxBound :: Int) + (maxBound :: Int) + 2 to get 0.
\begin{lstlisting}
>  maxBound :: Int
9223372036854775807
>  (maxBound :: Int) + 1
-9223372036854775808
>  (maxBound :: Int) + 2
-9223372036854775807
>  let x = (maxBound :: Int) + 1 in x + x
0
\end{lstlisting}
Why ``allow'' this to happen? Simple - efficiency. It's much faster to not check for if there'll be an integer overflow. This is the reason that Integer exists - it's unbounded, for when you think you might overflow, but you pay a price in efficiency.


\section*{Exercise 4}
Implemented in Exercise4.lhs.
The first two assignments where swap :: (Int, Int) (Int, Int) and swap :: (a, b)  (b, a) are implemented all work perfectly.
\newline
\newline
The difference is that the first pair ``(Int, (Char, Bool))'' consists of an int followed by a tuple of char and bool and the second pair ``(Int, Char, Bool)'' consists of the types int, char bool separately.
As for  the last question about datatypes, we can use a plethora of functions to achieve this. For example: \\
\textbf{fromIntegral} - to convert between say Int and Double\\
\textbf{pack / unpack} - to convert between ByteString and String\\
\textbf{read} - to convert from String to Int
\newline
An example implementation from Hoogle:
\begin{lstlisting}
fromIntegral = fromInteger . toInteger

{-# RULES
"fromIntegral/Int->Int" fromIntegral = id :: Int -> Int
  #-}

{-# RULES
"fromIntegral/Int->Word"  fromIntegral = \(I# x#) -> W# (int2Word# x#)
"fromIntegral/Word->Int"  fromIntegral = \(W# x#) -> I# (word2Int# x#)
"fromIntegral/Word->Word" fromIntegral = id :: Word -> Word
  #-}

-- | general coercion to fractional types
realToFrac :: (Real a, Fractional b) => a -> b
{-# NOINLINE [1] realToFrac #-}
realToFrac = fromRational . toRational
\end{lstlisting}


\section*{Exercise 5}


\section*{Exercise 6}


\end{document}
