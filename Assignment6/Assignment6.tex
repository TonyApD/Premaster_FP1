\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}

\begin{document}
\title{Functional Programming \\ Exercise set 6}
\date{\today}
\author{Tony Lopar s1013792 \\ Carlo Jessurun s1013793 \\ Marnix Dessing s1014097}
\maketitle

\section*{Exercise 1}
Code can be found in BinaryTree.lhs\\
The instance declarations aren't very useful. Ordering a binary tree is not a very useful action... Most of the time we are interested in what is in the binary tree and not if it is bigger or smaller in comparison with another tree. Besides that the definition of bigger or smaller is not really clear, is it the number of nodes? The total sum of values?\\
The Eq instance declaration could be more useful, a use case could be: A tree is the result from some sort of user input, and checking if the tree is the same as the original tree given to the user, could tell if the input is changed from the original data, and some action is now required...

\section*{Exercise 2}
\begin{enumerate}
  \item There are 4 ways to turn Bool into a monoid. These are all implemented in the file MapReduce.lhs. These are the functions And, or, unequal and equal.
  \item The Meaning of reduce means the following for each of the functions:
  \begin{enumerate}[label=\roman*)]
  \item AND: The reduce gives whether all values in the list are True
  \item OR: Whether one of the values in the list is True. The reduce will give false for the empty list.
  \item Equal: The function gives whether all values in the list are equal. However, if the list contains an uneven number of False the reduce will give False since the identity is True. In the case of an unequal number of elements an element is compared to the $\epsilon$.
  \item Unequal: The reduce gives whether there are no two equal values after eachother. A false is given when two equal values appear after eachother. The reduce still fails in some case with an odd number of true, for example: [True, False, True, False, True, True] gives the wrong result since the identity is False.
  \end{enumerate}
\end{enumerate}

\section*{Exercise 3}
The $\epsilon$ is the empty list and $\bullet$ stands for combining two ordered lists. A suitable instance declaration may be found in MapReduce.lhs.

The monoid can be used to implement a sorting function, but the prerequisite is that the lists of the input are already sorted. The can be achieved by first convert a list in runs and then take this runs as input.

\section*{Exercise 4}
\begin{enumerate}
  \item The difference in the types is caused by the order in which they process elements. The function foldr start at the first element of the list and iteres through the rest of the tail. The function foldl starts at the last element and iterates towards the head. Finally, the function foldm splits the list in two parts and does a recursion on both parts. Finally, foldm merges the result of the two sublists.
  \item The implementation can be found in MapReduce.lhs.
  \item The implementation can be found in MapReduce.lhs and is named foldmb to prevent a duplicate declaration with the implementation from the previous question.
\end{enumerate}
\section*{Exercise 5}
The implementation for this exercise can be found in the attached file MapReduce.lhs.
\section*{Exercise 6}
The implementation for this exercise can be found in the attached file DigitalSorting.lhs.


\end{document}
