\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}

\begin{document}
\title{Functional Programming \\ Exercise set 1}
\date{\today}
\author{Tony Lopar s1013792 \\ Carlo Jessurun s1013793 \\ Marnix Dessing s1014097}
\maketitle

\section*{Exercise 1}
The solutions for the exercises from 1 to 5 can be found in the Database.lhs file.

The following expressions are made for 6:
\begin{enumerate}[label=\alph*)]
  \item increment the age of all students by two: \\
  $map (\backslash p -> (age \enspace p+2, name \enspace p)) students$
  \item promote all of the students (attach ``dr '' to their name): \\
  $map (\backslash p -> (age \enspace p, name \enspace p \enspace ++ \enspace "dr")) students$
  \item find all students named Frits: \\
  $filter(\backslash p -> name \enspace p == "Frits") students$
  \item find all students whose favourite course is Functional Programming: \\
  $filter(\backslash p -> favouriteCourse \enspace p == "Functional \enspace Programming") students$
  \item find all students who are in their twenties: \\
  $filter(\backslash p -> age \enspace p >= 20 \enspace \&\& \enspace age \enspace p < 30 ) students$
  \item find all students whose favourite course is Functional Programming and who are in their twenties: \\ $filter(\backslash p -> favouriteCourse \enspace p == "Functional \enspace Programming" \enspace \&\& \enspace age \enspace p >= 20 \enspace \&\& \enspace age \enspace p < 30) students$
  \item find all students whose favourite course is Imperative Programming or who are in their twenties: \\ $filter(\backslash p -> favouriteCourse \enspace p == "Imperative \enspace Programming" \enspace || \enspace age \enspace p >= 20 \enspace \&\& \enspace age \enspace p < 30) students$
\end{enumerate}

\section*{Exercise 2}
\begin{enumerate}
  \item We need to evaluate the expresion: $insertionSort (7 : (9 : (2 : [ ]))$.
  Firstly $(7: (9: (2: [ ])))$ gets evaluated resulting in the list $[7,9,2]$. Then insert gets called with 7 and the rest of the list $[9,2]$. At this point seven is indeed lesser then 9 so the list gets returned. $[7,9]$. In insertionSort however, insertinoSort was called with xs as well. This is now called with $[9,2]$. Insert is then called with 9 and a list of $[2]$. Now the second guarded statement gets executed where 9 is indeed bigger then 2. insert will get one recursive call where b get's pushed into the list resulting in $[2,9]$. Going back up the same will be done with the remaining 7 which will result in \textbf{Result:} $[2,7,9]$.
  \item So first we will evaluate twice $(+1) 0$. This can be seen as $(+1) ((+1) 0)$ where $(+1) 0$ gets evaluated first and the result will be used as input for the second run of $(+1)$ the result is obviously 2.
  The second statement $twice twice (*2) 1$ can be seen as $(*2) ((*2) ((*2) ((*2) 1)))$ which results in 16.
  output of the list of statements:
  \begin{enumerate}
    \item ``Double pipe''
    \item ``Quadruple pipes''
    \item ``Sixteen pipes''
    \item ``Loads of pipes''
    \item ``Sixteen pipes''
    \item ``Not going to count this `amount` pipes''
    \item ``Same amount as above `amount` of pipes''
  \end{enumerate}
  The functions run in $2^n$ where n is the number of function calls.
\end{enumerate}

\section*{Exercise 3}
\begin{enumerate}
  \item
  Now the definition of twice has changed to: $twice = \backslash f \rightarrow \backslash x \rightarrow f (f x)$.
  Evaluating this statement obviously does the exact same as the previous definition $twice f x = f(f x)$. In this $\lambda$ version the lambda firstly gets a function and an x which as output has the function applied twice to x.
  \newline
  $twice (+1) 0$ then results in 2 and $twice twice (*2) 1$ results in 16. By hand the function evaluates exactly the same as in exercise 2.
  \item This is indeed interesting. As far as we know now, the function twice gets evaluated and has a certain output. That output determines the input of the next cycle of twice. Sicne we didn't have to give this function a type declaration because the compiler can infer by itself that it's a Integer to Integer function. So in this case we guess that its a Integer function given that the argument is $(*2) 1$.
\end{enumerate}

\section*{Exercise 4}
\begin{enumerate}
    \item Infix notation is much easier to read. But to interpret it correctly rules about associativity and binding need to be made. While with prefix or postfix those rules aren't needed.
    \item Possible use-cases of the function application operator \$ is every case in which a few functions need to be applied in a certain order while denoted in a compound statement.
    \item This is the logical choice, because the we read it from left to right. If the operator is infixr we would end up with different results:\\
    $(((1 \otimes 0) \otimes 1) \otimes 1) = 3$\\
    would become:\\
    $(1 \otimes (0 \otimes (1 \otimes 1))) = 5$
    \item $f ((x >= 0) \&\& (a || (((g (x (y * 7))) + 10) == (b-5))))$
\end{enumerate}


\section*{Exercise 5}
There were two repetitions in the poem. In the first line the number in the first line increments by one every couplet. In the second line, there is stated that the old man plays knick-knack on something different every time. In the last couplet there is stated that he played knick-knack once again.

The solution for this exercise can be found in the attached file Poem.lhs.

\section*{Exercise 6}
The solutions for this exercise can be found in the attached file Shapes.lhs.

\end{document}
