\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{multicol}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}

\begin{document}
\title{Functional Programming \\ Exercise set 7}
\date{\today}
\author{Tony Lopar s1013792 \\ Carlo Jessurun s1013793 \\ Marnix Dessing s1014097}
\maketitle

\section*{Exercise 1}

\section*{Exercise 2}
% data Tree elem = Empty $|$ Node (Tree elem) elem (Tree elem)
% inner :: Tree elem -> Integer
% inner Empty = 0
% inner (Node l a r) = 1 + inner l + inner l
%
% outer Empty = 1
% outer (Node l a r) = 0 + outer l + outer r
%
% inner t + 1 = outer t
% case t = Empty : inner Empty + 1
% = {definition of inner}
% 0 + 1 = 1
% = {definition of outer}
% outer Empty
%
% case t = Node l a r
% inner (Node l a r) + 1
% = {definition of inner}
% 1 + inner l + inner r + 1
% = {induction assumption}
% = outer l + inner r + 1
% = {induction assumption}
% = outer l + outer r
%
% outer l + outer r
% = {definition of outer}
% outer (Node l a r)
%
% 2^{minHeight t} − 1 <= size t <= 2^{maxHeight t} − 1
%
% minHeight :: Tree elem -> Int
% minHeight Empty = 0
% minHeight (Node l a r) = 1 + (minHeight l `min` minHeight r)
%
% case t = Empty:
% 2^{minHeight Empty} − 1
% = {definition of minHeight}
% 2^0 - 1
% = {arithmetic}
% 0
% = {definition of size}
% size Empty
%
% case t = Node l a r:
% 2^{minHeight (Node l a r)} − 1
% = {definition of minHeight}
% 2^{1 + (minHeight l `min` minHeight r)} - 1
% 2 \cdot 2^{minHeight l `min` minHeight r}
% 2^{minHeight l `min` minHeight r} + 2^{minHeight l `min` minHeight r}
% 1 + 2^{minHeight l} - 1 + 2^{minHeight r} - 1
% <= {induction assumption}
% 1 + size l + size r
% = {definition of size}
% size(Node l a r)

\section*{Exercise 3}
\section*{Exercise 4}
% not(a && b) = nod a || not b
% not a . and = or map not
% not(and[a, b]) = or(map not [a, b]) = or [not a, not b]
% not(a && b) = not a || not b
%
% not(foldr(&&) True bs)
% = {fusion}
%   foldr(=>) (not True) bs
%
% foldr(||) False(map not bs)
% = {foldr-map fusion}
%   foldr(\ab -> not a || b) False bs
%
% not(a && b) = a =>(implies) not b
%
% and = foldr (&&) True
% or = foldr (||) False
\section*{Exercise 5}
\section*{Exercise 6}


\end{document}
